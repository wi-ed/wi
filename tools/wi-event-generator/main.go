// Copyright 2014 Marc-Antoine Ruel. All rights reserved.
// Use of this source code is governed under the Apache License, Version 2.0
// that can be found in the LICENSE file.

// Generates editor/event_registry.go from wicore/events.go.
package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/parser"
	"go/token"
	"io/ioutil"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"

	"github.com/maruel/wi/tools/wi-event-generator/parse"
)

var tmplDecl = template.Must(template.New("decl").Parse(`// generated by {{.CmdLine}}; DO NOT EDIT

package {{.CurrentPkg}}

import (
	"io"

  "github.com/maruel/wi/wicore/key"
  "github.com/maruel/wi/wicore/lang"
)

// EventListener is to be used to cancel an event listener.
type EventListener interface {
	io.Closer
}

// NumberEvents is the number of known events.
const NumberEvents = {{len .Events}}

// EventRegistry permits to register callbacks that are called on events.
//
// Warning: This interface is automatically generated.
type EventRegistry interface {
	EventTrigger

{{range .Events}}
	Register{{.Name}}(callback func({{.Params.Flat $.CurrentPkg}})) EventListener{{end}}
}
`))

var tmplInternal = template.Must(template.New("internal").Parse(`// generated by {{.CmdLine}}; DO NOT EDIT

package {{.CurrentPkg}}

import (
  "github.com/maruel/wi/wicore"
  "github.com/maruel/wi/wicore/key"
  "github.com/maruel/wi/wicore/lang"
)

// EventTriggerRPC is the low level interface to propagate events to plugins.
//
// It is implemented by wi/wicore/plugin, exported here to be used via RPC.
type EventTriggerRPC interface {
	{{range .Events}}
	Trigger{{.Name}}RPC(packet Packet{{.Name}}, ignored *int) error{{end}}
}

{{range .Events}}
// Packet{{.Name}} is exported for internal RPC use.
type Packet{{.Name}} struct {
{{range .ParamsUpperCase}}  {{.Name}} {{.FullType $.CurrentPkg}}
{{end}} }
{{end}}
`))

// commonImpl is the common implementation code between the editor and the
// plugin. For now it is prefered to duplicate it than export it. That could
// change if an 'internal' package is created.
// TODO(maruel): Create a template that is imported.
var commonImpl = `
{{range .Events}}
type listener{{.Name}} struct{
	id       int
	callback func({{.Params.Flat $.CurrentPkg}})
}
{{end}}
// eventRegistry is automatically generated via wi-event-generator from the
// interface wicore.EventRegistry. It completely implements
// wicore.EventRegistry.
type eventRegistry struct {
  lock     sync.Mutex
  nextID   int
	deferred chan<- func()
{{range .Events}}
	{{.Lower}} []listener{{.Name}}{{end}}
}

func (er *eventRegistry) unregister(eventID int) {
  er.lock.Lock()
  defer er.lock.Unlock()
	// TODO(maruel): The buffers are never reallocated, so it's effectively a
	// memory leak.
	switch(eventID & {{.BitMask}}) { {{range .Events}}
	case {{.BitValue}}:
		for index, value := range er.{{.Lower}} {
			if value.id == eventID {
				copy(er.{{.Lower}}[index:], er.{{.Lower}}[index+1:])
				er.{{.Lower}} = er.{{.Lower}}[0 : len(er.{{.Lower}})-1]
				return
			}
		}{{end}}
  }
}{{range .Events}}

func (er *eventRegistry) Register{{.Name}}(callback func({{.Params.Flat $.CurrentPkg}})) wicore.EventListener {
  er.lock.Lock()
  defer er.lock.Unlock()
  i := er.nextID
  er.nextID++
  er.{{.Lower}} = append(er.{{.Lower}}, listener{{.Name}}{i, callback})
  return &eventListener{er, i | {{.BitValue}}}
}{{end}}{{range .Events}}

func (er *eventRegistry) {{$.Trigger}}{{.Name}}({{.Params.Flat $.CurrentPkg}}) {
	er.deferred <- func() {
		items := func() []func({{.Params.Flat $.CurrentPkg}}) {
			er.lock.Lock()
			defer er.lock.Unlock()
			items := make([]func({{.Params.Flat $.CurrentPkg}}), 0, len(er.{{.Lower}}))
			for _, item := range er.{{.Lower}} {
				items = append(items, item.callback)
			}
			return items
		}()
		for _, item := range items {
			item({{.Params.Names}})
		}
	}
}{{end}}

type unregister interface {
  unregister(id int)
}

type eventListener struct {
	unregister unregister
	id int
}

func (e *eventListener) Close() error {
	if e.id == 0 {
		return errors.New("EventListener already closed")
	}
	e.unregister.unregister(e.id)
	e.id = 0
	return nil
}
`

var tmplEditorImpl = template.Must(template.New("editor").Parse(`// generated by {{.CmdLine}}; DO NOT EDIT

package {{.CurrentPkg}}

import (
  "errors"
	"log"
	"net/rpc"
  "sync"

  "github.com/maruel/wi/internal"
  "github.com/maruel/wi/wicore"
  "github.com/maruel/wi/wicore/key"
  "github.com/maruel/wi/wicore/lang"
)

// makeEventRegistry returns a wicore.EventRegistry and the channel to read
// from to run the events piped in.
func makeEventRegistry() (wicore.EventRegistry, chan func()) {
	// Reduce the odds of allocation within RegistryXXX() by using relatively
	// large buffers.
	c := make(chan func(), 2048)
	e := &eventRegistry{
		deferred: c,{{range .Events}}
		{{.Lower}}: make([]listener{{.Name}}, 0, 64),{{end}}
	}
	return e, c
}

// registerPluginEvents registers all the events to be forwarded to the plugin
// through the interface EventTriggerRPC.
func registerPluginEvents(client *rpc.Client, e wicore.EventRegistry) wicore.EventListener {
	return wicore.MultiCloser{ {{range .Events}}
		e.Register{{.Name}}(func({{.Params.Flat $.CurrentPkg}}) {
			packet := internal.Packet{{.Name}} { {{.Params.Names}} }
			out := 0
			if err := client.Call("EventTriggerRPC.Trigger{{.Name}}RPC", packet, &out); err != nil {
				log.Printf("RPC {{.Name}} call failure: %s", err)
			}
		}),{{end}}
	}
}
` + commonImpl))

var tmplPluginImpl = template.Must(template.New("plugin").Parse(`// generated by {{.CmdLine}}; DO NOT EDIT

package {{.CurrentPkg}}

import (
  "errors"
  "sync"

  "github.com/maruel/wi/internal"
  "github.com/maruel/wi/wicore"
  "github.com/maruel/wi/wicore/key"
  "github.com/maruel/wi/wicore/lang"
)

type eventTriggerRPC struct {
	eventRegistry
}

// makeEventRegistry returns a wicore.EventRegistry and the channel to read
// from to run the events piped in.
func makeEventRegistry() (wicore.EventRegistry, internal.EventTriggerRPC, chan func()) {
	// Reduce the odds of allocation within RegistryXXX() by using relatively
	// large buffers.
	c := make(chan func(), 2048)
	e := &eventTriggerRPC{
		eventRegistry{
			deferred: c,{{range .Events}}
			{{.Lower}}: make([]listener{{.Name}}, 0, 64),{{end}}
		},
	}
	return e, e, c
}{{range .Events}}

func (er *eventTriggerRPC) Trigger{{.Name}}RPC(packet internal.Packet{{.Name}}, ignored *int) error {
	er.trigger{{.Name}}({{.PacketParams}})
	return nil
}{{end}}{{range .Events}}

func (er *eventRegistry) Trigger{{.Name}}({{.Params.Flat $.CurrentPkg}}) {
	// TODO(maruel): Send it upstream to the editor.
}{{end}}
` + commonImpl))

// Event describes one parsed event from the interface that will be used to
// generate the code.
type Event struct {
	Name            string
	Lower           string
	Index           int
	BitValue        string
	Params          parse.Args // []Arg{{"foo", "int"}, {"bar", "string"}}
	ParamsUpperCase parse.Args // []Arg{{"Foo", "int"}, {"Bar", "string"}}
	PacketParams    string     // "packet.foo, packet.bar"
}

type tmplData struct {
	BitMask    string
	CmdLine    string
	CurrentPkg string
	Events     []Event
	Trigger    string // lowercase if not exported, in case of plugin.
}

// Generation code.

func extractEvents(inputFile, inputType string, bitmask uint) ([]Event, error) {
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, inputFile, nil, 0)
	if err != nil {
		return nil, err
	}
	prefix := "Trigger"
	events := []Event{}
	inputT := parse.FindType(f, inputType)
	if inputT == nil {
		return nil, fmt.Errorf("failed to find type %s", inputType)
	}
	pkgName := f.Name.Name
	methods, err := parse.EnumInterface(pkgName, inputT)
	if err != nil {
		return nil, err
	}
	methodNames := make([]string, len(methods))
	for i, m := range methods {
		methodNames[i] = m.Name
	}
	if !sort.StringsAreSorted(methodNames) {
		return nil, fmt.Errorf("methods of %s must be sorted by name", inputType)
	}
	for _, method := range methods {
		if !strings.HasPrefix(method.Name, prefix) {
			return nil, fmt.Errorf("method %s.%s doesn't have prefix %s", inputType, method.Name, prefix)
		}
		if len(method.Results) != 0 {
			return nil, fmt.Errorf("unexpected result on method %s.%s", inputType, method.Name)
		}
		name := method.Name[len(prefix):]
		lower := strings.ToLower(name[0:1]) + name[1:]
		paramsUpper := make(parse.Args, len(method.Params))
		packetParams := make([]string, len(method.Params))
		for i, arg := range method.Params {
			if len(arg.Name) == 0 {
				return nil, fmt.Errorf("argument %d must be named on method %s.%s", i, inputType, method.Name)
			}
			paramsUpper[i] = arg
			paramsUpper[i].Name = strings.ToUpper(paramsUpper[i].Name[0:1]) + paramsUpper[i].Name[1:]
			packetParams[i] = "packet." + paramsUpper[i].Name
		}
		// TODO(maruel): It creates an artificial limit of 2^23 event listener and
		// 2^8 event types on 32 bits systems.
		events = append(events, Event{
			Name:            name,
			Lower:           lower,
			Index:           len(events),
			BitValue:        fmt.Sprintf("0x%x", (len(events)+1)<<bitmask),
			Params:          method.Params,
			ParamsUpperCase: paramsUpper,
			PacketParams:    strings.Join(packetParams, ", "),
		})
	}
	return events, nil
}

func load(inputFile string, inputType string) (*tmplData, error) {
	// TODO(maruel): Make the bitmask seamless instead of hardcoded.
	bitmask := uint(24)
	events, err := extractEvents(inputFile, inputType, bitmask)
	if err != nil {
		return nil, err
	}
	return &tmplData{
		BitMask:    fmt.Sprintf("0x%x", ((1<<32)-1)-((1<<bitmask)-1)),
		CmdLine:    "go run ../tools/wi-event-generator/main.go " + strings.Join(os.Args[1:], " "), // Skip os.Args[0]Â since it may point into $TMP.
		CurrentPkg: "wicore",
		Events:     events,
		Trigger:    "Trigger",
	}, err
}

func generate(d *tmplData, tmpl *template.Template, outputFile string) error {
	out := bytes.Buffer{}
	if err := tmpl.Execute(&out, d); err != nil {
		return fmt.Errorf("failed to generate go code: %s", err)
	}
	src, err := parse.FormatSource(out.Bytes())
	err2 := ioutil.WriteFile(outputFile, src, 0644)
	if err != nil {
		return err
	}
	return err2
}

func mainImpl() error {
	flag.Parse()

	if len(flag.Args()) != 0 {
		return fmt.Errorf("unexpected argument: %s", flag.Args())
	}

	t, err := load("interfaces.go", "EventTrigger")
	if err != nil {
		return err
	}
	if err := generate(t, tmplDecl, "event_registry_decl.go"); err != nil {
		return err
	}
	t.CurrentPkg = "editor"
	if err := generate(t, tmplEditorImpl, filepath.Join("..", "editor", "event_registry_impl.go")); err != nil {
		return err
	}
	t.CurrentPkg = "plugin"
	t.Trigger = "trigger"
	if err := generate(t, tmplPluginImpl, filepath.Join("plugin", "event_registry_impl.go")); err != nil {
		return err
	}
	t.CurrentPkg = "internal"
	t.Trigger = "Trigger"
	if err := generate(t, tmplInternal, filepath.Join("..", "internal", "event_registry_internal.go")); err != nil {
		return err
	}
	return nil
}

func main() {
	if err := mainImpl(); err != nil {
		fmt.Fprintf(os.Stderr, "wi-event-generator: %s.\n", err)
		os.Exit(1)
	}
}
